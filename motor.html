<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vestweb Engine v2.0 - High-Performance WebGL/WebGPU Graphics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            margin: 0; overflow: hidden; background: #000; 
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            cursor: default;
        }
        canvas { 
            display: block; width: 100vw; height: 100vh;
            touch-action: none; /* Evita scroll en móviles */
        }
        
        /* UI Panel - Optimizado */
        #ui {
            position: absolute; top: 15px; left: 15px; color: #0ff;
            background: rgba(0, 10, 15, 0.95); padding: 15px; 
            border: 1px solid rgba(0, 255, 255, 0.5);
            pointer-events: none; user-select: none; 
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            border-radius: 4px; min-width: 280px;
            font-size: 11px; backdrop-filter: blur(5px);
        }
        h1 { 
            margin: 0 0 12px 0; font-size: 13px; 
            text-transform: uppercase; letter-spacing: 3px; 
            border-bottom: 1px solid rgba(0, 255, 255, 0.3); 
            padding-bottom: 8px; color: #0ff;
        }
        .stat { 
            font-size: 10px; color: #8cf; margin-bottom: 4px; 
            display: flex; justify-content: space-between; 
        }
        .val { font-weight: bold; color: #fff; }
        .section { margin-top: 12px; padding-top: 8px; border-top: 1px solid rgba(0,255,255,0.15); }
        .section-title { color: #0cf; font-size: 10px; margin-bottom: 6px; font-weight: bold; }
        .warn { color: #fa0; font-size: 9px; margin-top: 10px; opacity: 0.9; }
        
        /* Controls Helper */
        #controls {
            position: absolute; bottom: 15px; left: 15px; color: #8cf;
            background: rgba(0, 10, 15, 0.95); padding: 12px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px; font-size: 9px;
            pointer-events: none; backdrop-filter: blur(5px);
        }
        #controls div { margin-bottom: 3px; }
        
        /* Loading Screen */
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; align-items: center; justify-content: center;
            flex-direction: column; z-index: 1000; transition: opacity 0.5s;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        .spinner { border: 3px solid rgba(0,255,255,0.3); border-top: 3px solid #0ff;
            border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .load-text { color: #0ff; margin-top: 20px; font-size: 12px; letter-spacing: 2px; }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="spinner"></div>
        <div class="load-text">INITIALIZING ENGINE...</div>
    </div>
    
    <!-- Main UI Panel -->
    <div id="ui">
        <h1>⚡ VESTWEB ENGINE v2.0</h1>
        
        <div class="stat">FPS <span class="val" id="fpsCounter">0</span></div>
        <div class="stat">Samples <span class="val" id="sampleCount">0</span></div>
        <div class="stat">Resolution <span class="val" id="resolution">--</span></div>
        <div class="stat">GPU <span class="val" id="gpuInfo">WebGL2</span></div>
        
        <div class="section">
            <div class="section-title">RENDERING</div>
            <div class="stat">▸ PBR + Ray Tracing</div>
            <div class="stat">▸ SSAO + Bloom + DOF</div>
            <div class="stat">▸ Volumetric Fog</div>
            <div class="stat">▸ Chromatic Dispersion</div>
        </div>
        
        <div class="section">
            <div class="section-title">PHYSICS SYSTEM</div>
            <div class="stat">Objects <span class="val" id="physicsObjects">0</span></div>
            <div class="stat">Collisions <span class="val" id="collisions">0</span></div>
            <div class="stat">Gravity <span class="val" id="gravity">ON</span></div>
        </div>
        
        <div class="warn">⚠ High GPU load - Optimized for all platforms</div>
    </div>
    
    <!-- Controls Helper -->
    <div id="controls">
        <div><strong>CONTROLS:</strong></div>
        <div>WASD - Move Camera</div>
        <div>Mouse Drag - Look Around</div>
        <div>Space - Jump / Up</div>
        <div>Shift - Down</div>
        <div>R - Reset Camera</div>
        <div>P - Toggle Physics</div>
        <div>G - Toggle Gravity</div>
    </div>
    
    <canvas id="glcanvas"></canvas>

    <!-- ================================================================================================
         VERTEX SHADER - Optimizado para fullscreen quad
         ================================================================================================ -->
    <script id="vs" type="x-shader/x-vertex">#version 300 es
        in vec4 position;
        void main() { gl_Position = position; }
    </script>

    <!-- ================================================================================================
         FRAGMENT SHADER - VESTWEB Engine Advanced Renderer
         Optimizado para WebGL2 con técnicas de PBR, RT, SSAO, Bloom, DOF y Physics
         Compatible: macOS (Apple Silicon/Intel), Windows (Nvidia/AMD), Linux
         ================================================================================================ -->
    <script id="fs" type="x-shader/x-fragment">#version 300 es
    precision highp float;
    precision highp int;
    precision highp sampler2D;

    // ═══════════════════════════════════════════════════════════════════════════════
    // UNIFORMS - Entradas desde CPU
    // ═══════════════════════════════════════════════════════════════════════════════
    uniform vec2 u_resolution;      // Resolución de pantalla
    uniform float u_time;           // Tiempo en segundos
    uniform int u_frame;            // Número de frame actual
    uniform sampler2D u_texture;    // Buffer anterior (ping-pong)
    uniform vec3 u_camPos;          // Posición de cámara
    uniform vec3 u_camDir;          // Dirección de cámara (forward)
    uniform vec3 u_camUp;           // Vector up de cámara
    
    // Physics Objects (máx 20 esferas dinámicas)
    #define MAX_PHYSICS_OBJECTS 20
    uniform vec3 u_physicsPos[MAX_PHYSICS_OBJECTS];   // Posiciones
    uniform float u_physicsRadius[MAX_PHYSICS_OBJECTS]; // Radios
    uniform int u_physicsCount;                        // Cantidad activa
    
    out vec4 outColor;

    // ═══════════════════════════════════════════════════════════════════════════════
    // 1. CORE CONSTANTS & OPTIMIZATIONS
    // ═══════════════════════════════════════════════════════════════════════════════
    #define PI 3.14159265359
    #define TWO_PI 6.28318530718
    #define INV_PI 0.31830988618
    #define HALF_PI 1.57079632679
    
    // Ray marching optimizado para diferentes GPUs
    #define MAX_BOUNCES 5          // Rebotes de ray tracing (5 para mejor calidad)
    #define MAX_STEPS 120          // Pasos de ray marching
    #define MAX_DIST 250.0         // Distancia máxima de renderizado
    #define EPSILON 0.0008         // Epsilon para detección de superficie
    #define NORMAL_EPSILON 0.001   // Epsilon para cálculo de normales
    #define INFINITY 1e20
    
    // Optimizaciones de rendering
    #define ENABLE_SSAO true       // Screen Space Ambient Occlusion
    #define ENABLE_BLOOM true      // Bloom post-process
    #define ENABLE_DOF false       // Depth of Field (costoso)
    #define ENABLE_SHADOWS true    // Sombras en tiempo real
    
    // Math utilities optimizadas
    float sqr(float x) { return x * x; }
    float pow5(float x) { float x2 = x * x; return x2 * x2 * x; }
    
    // Luminance (ITU-R BT.709)
    float luminance(vec3 c) { 
        return dot(c, vec3(0.2126, 0.7152, 0.0722)); 
    }
    
    // Safe clamp para evitar valores extremos (crítico en macOS)
    vec3 safeClamp(vec3 c) {
        return clamp(c, vec3(0.0), vec3(100.0));
    }
    
    // Saturate helper
    float saturate(float x) { return clamp(x, 0.0, 1.0); }
    vec3 saturate3(vec3 x) { return clamp(x, vec3(0.0), vec3(1.0)); }

    // ==================================================================================
    // 2. ROBUST RANDOM NUMBER GENERATOR (NO TRIGONOMETRY)
    // ==================================================================================
    // Uses PCG-style hashing purely on uints. Indestructible stability.
    uint hash(uint x) {
        x += (x << 10u);
        x ^= (x >> 6u);
        x += (x << 3u);
        x ^= (x >> 11u);
        x += (x << 15u);
        return x;
    }
    
    uint rngState;
    
    void initRNG() {
        uint pixelIndex = uint(gl_FragCoord.x) + uint(gl_FragCoord.y) * uint(u_resolution.x);
        rngState = pixelIndex * 1973u + uint(u_frame) * 9277u + 26699u;
    }

    float rand() {
        rngState = hash(rngState);
        return float(rngState) * (1.0 / 4294967295.0);
    }

    vec3 randomSphere() {
        float z = rand() * 2.0 - 1.0;
        float a = rand() * TWO_PI;
        float r = sqrt(1.0 - z * z);
        return vec3(r * cos(a), r * sin(a), z);
    }

    vec3 randomHemisphere(vec3 n) {
        vec3 v = randomSphere();
        return v * sign(dot(v, n));
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // 3. PBR & DISNEY PRINCIPLED BSDF (Optimizado)
    // ═══════════════════════════════════════════════════════════════════════════════
    
    // Fresnel Schlick (optimizado con pow5)
    float fresnelSchlick(float cosTheta) {
        return pow5(saturate(1.0 - cosTheta));
    }
    
    vec3 fresnelSchlickVec(float cosTheta, vec3 F0) {
        return F0 + (vec3(1.0) - F0) * pow5(saturate(1.0 - cosTheta));
    }
    
    // GGX/Trowbridge-Reitz Normal Distribution Function
    float distributionGGX(float NdotH, float roughness) {
        float a = roughness * roughness;
        float a2 = a * a;
        float denom = NdotH * NdotH * (a2 - 1.0) + 1.0;
        return a2 / (PI * denom * denom);
    }
    
    // Smith GGX Geometry Function (Schlick-GGX)
    float geometrySchlickGGX(float NdotV, float roughness) {
        float r = roughness + 1.0;
        float k = (r * r) / 8.0;
        return NdotV / (NdotV * (1.0 - k) + k);
    }
    
    float geometrySmith(float NdotV, float NdotL, float roughness) {
        float ggx1 = geometrySchlickGGX(NdotV, roughness);
        float ggx2 = geometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
    }
    
    // Cook-Torrance BRDF (PBR Specular)
    vec3 cookTorranceBRDF(vec3 N, vec3 V, vec3 L, vec3 albedo, float metallic, float roughness) {
        vec3 H = normalize(V + L);
        
        float NdotV = max(dot(N, V), 0.0001);
        float NdotL = max(dot(N, L), 0.0001);
        float NdotH = max(dot(N, H), 0.0);
        float VdotH = max(dot(V, H), 0.0);
        
        // Fresnel
        vec3 F0 = mix(vec3(0.04), albedo, metallic);
        vec3 F = fresnelSchlickVec(VdotH, F0);
        
        // Distribution
        float D = distributionGGX(NdotH, roughness);
        
        // Geometry
        float G = geometrySmith(NdotV, NdotL, roughness);
        
        // Cook-Torrance specular
        vec3 specular = (D * F * G) / max(4.0 * NdotV * NdotL, 0.001);
        
        // Energy conservation
        vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);
        
        // Lambertian diffuse
        vec3 diffuse = kD * albedo * INV_PI;
        
        return (diffuse + specular) * NdotL;
    }
    
    // Dielectric Fresnel para refracción (Snell's Law completo)
    float fresnelDielectric(float cosThetaI, float eta) {
        float sinThetaT2 = eta * eta * (1.0 - cosThetaI * cosThetaI);
        if (sinThetaT2 > 1.0) return 1.0; // Total internal reflection
        
        float cosThetaT = sqrt(max(0.0, 1.0 - sinThetaT2));
        float rs = (eta * cosThetaI - cosThetaT) / (eta * cosThetaI + cosThetaT);
        float rp = (cosThetaI - eta * cosThetaT) / (cosThetaI + eta * cosThetaT);
        return 0.5 * (rs * rs + rp * rp);
    }
    
    // Multiple scattering compensation (Kulla-Conty)
    vec3 multipleScattering(vec3 F0, float roughness, float NdotV) {
        float a = roughness * roughness;
        vec3 E_avg = vec3(1.0 - 0.033 * a * a);
        vec3 F_avg = F0 + (vec3(1.0) - F0) / 21.0;
        vec3 FssEss = fresnelSchlickVec(NdotV, F0);
        return FssEss * E_avg / (vec3(1.0) - F_avg * (1.0 - E_avg));
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // 4. SCENE GEOMETRY (SDFs) - DEBE IR ANTES DE POST-PROCESSING
    // ═══════════════════════════════════════════════════════════════════════════════
    
    // Primitives
    float sdSphere(vec3 p, float s) { return length(p) - s; }
    float sdBox(vec3 p, vec3 b) {
        vec3 q = abs(p) - b;
        return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
    }
    
    // 2D Rotation
    void pR(inout vec2 p, float a) {
        float c = cos(a); float s = sin(a);
        p = vec2(c*p.x - s*p.y, s*p.x + c*p.y);
    }

    // Fractal: KIFS (Kaleidoscopic Iterated Function System) - Nivel 5
    float sdKIFS(vec3 p) {
        float scale = 1.8;
        float offset = 1.0;
        float d = 1000.0;
        // 5 Iteraciones para máximo detalle visual
        for(int i=0; i<5; i++) {
            p = abs(p);
            if (p.x < p.y) p.xy = p.yx;
            if (p.x < p.z) p.xz = p.zx;
            if (p.y < p.z) p.yz = p.zy;
            
            p.z -= 0.4 * offset * (scale - 1.0) / scale;
            p.z = -abs(p.z);
            p.z += 0.4 * offset * (scale - 1.0) / scale;
            
            p.x = scale * p.x - offset * (scale - 1.0);
            p.y = scale * p.y - offset * (scale - 1.0);
            p.z = scale * p.z;
            
            if (i > 1) pR(p.xy, 0.5); // Rotación determinista
            
            scale *= 1.5;
            d = min(d, length(p) * pow(scale, -1.0));
        }
        return d - 0.02;
    }

    // Scene Map
    // IDs: 1=Suelo, 2=Fractal, 3=Cristal, 4=Metal, 5=PhysicsObjects, 90-92=Luces
    vec2 map(vec3 p) {
        vec2 res = vec2(MAX_DIST, 0.0);

        // Suelo
        float dPlane = p.y + 2.0;
        if(dPlane < res.x) res = vec2(dPlane, 1.0);

        // Fractal Central (Sin bounding box optimizado para evitar glitches)
        float dK = sdKIFS(p * 0.6) / 0.6;
        if(dK < res.x) res = vec2(dK, 2.0);

        // Cristal (Derecha)
        vec3 pSph = p - vec3(3.5, 0.0, -1.0);
        float dSph = sdSphere(pSph, 1.5);
        if(dSph < res.x) res = vec2(dSph, 3.0);

        // Metal (Izquierda)
        vec3 pBox = p - vec3(-3.5, 0.0, 2.0);
        pR(pBox.xz, 0.4);
        float dBox = sdBox(pBox, vec3(1.0)) - 0.1;
        if(dBox < res.x) res = vec2(dBox, 4.0);

        // Physics Objects dinámicos
        for(int i = 0; i < MAX_PHYSICS_OBJECTS; i++) {
            if(i >= u_physicsCount) break;
            vec3 pPhys = p - u_physicsPos[i];
            float dPhys = sdSphere(pPhys, u_physicsRadius[i]);
            if(dPhys < res.x) res = vec2(dPhys, 5.0);
        }

        // --- LUCES ---
        vec3 pL1 = p - vec3(3.0, 3.0, 3.0);
        float dL1 = sdSphere(pL1, 0.4);
        if(dL1 < res.x) res = vec2(dL1, 90.0);

        vec3 pL2 = p - vec3(-4.0, 2.0, -3.0);
        float dL2 = sdSphere(pL2, 0.4);
        if(dL2 < res.x) res = vec2(dL2, 91.0);

        vec3 pArea = p - vec3(0.0, 8.0, 0.0);
        float dArea = sdBox(pArea, vec3(3.0, 0.1, 3.0));
        if(dArea < res.x) res = vec2(dArea, 92.0);

        return res;
    }

    // Normales
    vec3 calcNormal(vec3 p) {
        vec2 e = vec2(1.0, -1.0) * NORMAL_EPSILON;
        return normalize(
            e.xyy * map(p + e.xyy).x + e.yyx * map(p + e.yyx).x +
            e.yxy * map(p + e.yxy).x + e.xxx * map(p + e.xxx).x
        );
    }

    // --- RAY MARCHING ---
    struct Hit { float t; int id; vec3 p; vec3 n; vec3 tangent; vec3 bitangent; };

    // ═══════════════════════════════════════════════════════════════════════════════
    // 5. POST-PROCESSING EFFECTS (SSAO, Bloom, DOF)
    // ═══════════════════════════════════════════════════════════════════════════════
    
    // Screen Space Ambient Occlusion (SSAO) - Aproximación rápida
    float calculateSSAO(vec3 p, vec3 n, float seed) {
        float ao = 0.0;
        float weight = 1.0;
        const int samples = 4; // Reducido para performance
        
        for (int i = 0; i < samples; i++) {
            float fi = float(i);
            vec3 offset = normalize(vec3(
                sin(seed + fi * 2.4),
                cos(seed + fi * 3.1),
                sin(seed + fi * 1.7)
            )) * (0.1 + fi * 0.15);
            
            // Solo muestrear en hemisferio
            offset *= sign(dot(offset, n));
            
            float sampleDist = length(offset);
            vec3 samplePos = p + offset;
            
            // Evaluar distancia a la escena
            float sceneDist = map(samplePos).x;
            
            // Si hay geometría cerca, contribuye a oclusión
            ao += step(sceneDist, sampleDist) * weight;
            weight *= 0.7;
        }
        
        return 1.0 - saturate(ao * 0.3);
    }
    
    // Bloom threshold y blur
    vec3 bloomThreshold(vec3 color, float threshold) {
        float brightness = luminance(color);
        return color * smoothstep(threshold, threshold + 0.5, brightness);
    }
    
    // Depth of Field (bokeh simple)
    float getDepthOfField(float depth, float focusDistance, float aperture) {
        return abs(depth - focusDistance) * aperture;
    }

    Hit intersect(vec3 ro, vec3 rd) {
        Hit hit; hit.t = -1.0; float t = 0.1;
        for(int i=0; i<MAX_STEPS; i++) {
            vec3 p = ro + rd * t;
            vec2 d = map(p);
            
            if(abs(d.x) < EPSILON) {
                hit.t = t; hit.id = int(d.y); hit.p = p; hit.n = calcNormal(p);
                // Tangentes para anisotropía
                vec3 c1 = cross(hit.n, vec3(0,0,1));
                vec3 c2 = cross(hit.n, vec3(0,1,0));
                hit.tangent = normalize(length(c1)>length(c2)?c1:c2);
                hit.bitangent = cross(hit.n, hit.tangent);
                return hit;
            }
            
            t += d.x;
            if(t > MAX_DIST) break;
        }
        return hit;
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // 6. MATERIAL SYSTEM - PBR Materials
    // ═══════════════════════════════════════════════════════════════════════════════
    
    struct Material {
        vec3 albedo;
        float metallic;
        float roughness;
        float transmission;
        float ior;
        vec3 emission;
        float subsurface;
        float ao; // Ambient occlusion factor
    };

    Material getMaterial(int id, vec3 p, vec3 n) {
        Material mat;
        
        // Defaults
        mat.albedo = vec3(0.8);
        mat.metallic = 0.0;
        mat.roughness = 0.5;
        mat.transmission = 0.0;
        mat.ior = 1.5;
        mat.emission = vec3(0.0);
        mat.subsurface = 0.0;
        mat.ao = 1.0;

        if (id == 1) {
            // Suelo con patrón de ajedrez y variación
            float checker = mod(floor(p.x) + floor(p.z), 2.0);
            mat.albedo = vec3(0.12, 0.11, 0.13) + vec3(0.08) * checker;
            mat.roughness = 0.6 + 0.2 * checker;
            mat.metallic = 0.05;
        }
        else if (id == 2) {
            // Fractal - Material cerámica con SSS
            mat.albedo = vec3(0.95, 0.8, 0.6);
            mat.roughness = 0.35;
            mat.subsurface = 0.8;
            mat.metallic = 0.0;
            
            // Variación procedural
            float noise = sin(p.x * 5.0) * sin(p.y * 3.0) * sin(p.z * 4.0);
            mat.roughness += noise * 0.1;
        }
        else if (id == 3) {
            // Cristal transparente con dispersión
            mat.albedo = vec3(0.98, 1.0, 0.98);
            mat.transmission = 0.95;
            mat.roughness = 0.02;
            mat.ior = 1.52; // Vidrio
            mat.metallic = 0.0;
        }
        else if (id == 4) {
            // Metal dorado pulido
            mat.albedo = vec3(1.0, 0.78, 0.34);
            mat.metallic = 1.0;
            mat.roughness = 0.15;
        }
        else if (id == 5) {
            // Physics Objects - Material plástico colorido
            mat.albedo = vec3(0.8, 0.3, 0.2);
            mat.roughness = 0.4;
            mat.metallic = 0.0;
            mat.subsurface = 0.2;
        }
        // Luces emisivas
        else if (id == 90) {
            mat.emission = vec3(25.0, 2.0, 2.0);
            mat.albedo = vec3(1.0, 0.0, 0.0);
        }
        else if (id == 91) {
            mat.emission = vec3(2.0, 8.0, 25.0);
            mat.albedo = vec3(0.0, 0.5, 1.0);
        }
        else if (id == 92) {
            mat.emission = vec3(8.0, 8.0, 7.0);
            mat.albedo = vec3(1.0);
        }

        return mat;
    }

    // Atmospheric scattering mejorado (Rayleigh + Mie)
    vec3 getAtmosphere(vec3 rd) {
        vec3 sunDir = normalize(vec3(0.5, 0.7, 0.4));
        float sunDot = dot(rd, sunDir);
        
        // Rayleigh scattering (cielo azul)
        vec3 rayleigh = vec3(0.06, 0.15, 0.4) * (1.0 + sunDot * sunDot);
        
        // Mie scattering (halo solar)
        float mie = pow(saturate(sunDot), 64.0);
        vec3 mieColor = vec3(1.0, 0.95, 0.8) * mie * 1.5;
        
        // Horizonte gradiente
        float horizon = pow(1.0 - abs(rd.y), 2.0);
        vec3 horizonColor = vec3(0.8, 0.5, 0.3) * horizon * 0.3;
        
        // Ambient base
        vec3 ambient = vec3(0.03, 0.04, 0.06);
        
        return rayleigh + mieColor + horizonColor + ambient;
    }
    
    // Fog volumétrico heterogéneo mejorado
    vec3 calculateVolumetricFog(vec3 ro, vec3 rd, float tMax) {
        vec3 fog = vec3(0.0);
        float t = 0.0;
        const int steps = 8;
        float stepSize = tMax / float(steps);
        
        for (int i = 0; i < steps; i++) {
            vec3 p = ro + rd * t;
            
            // Densidad variable con ruido
            float density = 0.006 * (0.5 + 0.5 * sin(p.x * 0.3 + p.z * 0.4));
            density *= exp(-p.y * 0.15); // Más denso cerca del suelo
            
            // In-scattering desde luz ambiente
            vec3 inscatter = vec3(0.06, 0.08, 0.12) * density;
            fog += inscatter * stepSize;
            
            t += stepSize;
        }
        
        return saturate3(fog);
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // 7. PATH TRACER - Ray tracing integrator mejorado
    // ═══════════════════════════════════════════════════════════════════════════════
    
    // Soft shadows con múltiples muestras
    float calculateShadow(vec3 ro, vec3 rd, float maxDist) {
        float shadow = 1.0;
        float t = 0.02;
        
        for (int i = 0; i < 32; i++) {
            float h = map(ro + rd * t).x;
            if (h < EPSILON) return 0.0;
            
            // Soft shadow penumbra
            shadow = min(shadow, 8.0 * h / t);
            t += h;
            
            if (t > maxDist) break;
        }
        
        return saturate(shadow);
    }
    
    vec3 pathTrace(vec3 rayOrigin, vec3 rayDir) {
        vec3 radiance = vec3(0.0);
        vec3 throughput = vec3(1.0);
        float spectralWavelength = rand(); // Para dispersión cromática
        
        vec3 ro = rayOrigin;
        vec3 rd = rayDir;
        
        for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
            Hit hit = intersect(ro, rd);
            
            // Fog volumétrico solo en primer rebote
            if (bounce == 0 && ENABLE_SSAO) {
                float hitDist = hit.t > 0.0 ? hit.t : 50.0;
                vec3 fog = calculateVolumetricFog(ro, rd, hitDist);
                radiance += throughput * fog * 0.4;
                throughput *= exp(-fog * 0.3); // Absorción
            }
            
            // Miss - renderizar atmósfera
            if (hit.t < 0.0) {
                radiance += throughput * getAtmosphere(rd);
                break;
            }
            
            // Obtener material
            Material mat = getMaterial(hit.id, hit.p, hit.n);
            
            // Emisión directa
            if (length(mat.emission) > 0.0) {
                radiance += throughput * mat.emission;
                break;
            }
            
            vec3 N = hit.n;
            vec3 V = -rd;
            
            // SSAO si está habilitado
            if (ENABLE_SSAO && bounce == 0) {
                float ao = calculateSSAO(hit.p, N, u_time + float(u_frame));
                mat.ao *= ao;
            }
            
            // ─────────────────────────────────────────────────────────────────────
            // MATERIAL BRANCHING
            // ─────────────────────────────────────────────────────────────────────
            
            if (mat.transmission > 0.9) {
                // ═══ GLASS / TRANSMISSION ═══
                float ior = mat.ior;
                
                // Dispersión cromática
                if (spectralWavelength < 0.33) ior -= 0.018; // Rojo
                else if (spectralWavelength > 0.66) ior += 0.018; // Azul
                
                bool entering = dot(rd, N) < 0.0;
                float eta = entering ? 1.0 / ior : ior;
                vec3 normal = entering ? N : -N;
                
                // Calcular refracción
                vec3 refracted = refract(rd, normal, eta);
                float fresnel = fresnelDielectric(abs(dot(rd, normal)), eta);
                
                // Decisión: reflexión o refracción
                if (length(refracted) < 0.1 || rand() < fresnel) {
                    // Reflexión
                    rd = reflect(rd, normal);
                    ro = hit.p + rd * 0.01;
                } else {
                    // Refracción con tinte espectral
                    rd = refracted;
                    ro = hit.p + rd * 0.01;
                    
                    if (spectralWavelength < 0.33) throughput *= vec3(1.5, 0.1, 0.1);
                    else if (spectralWavelength > 0.66) throughput *= vec3(0.1, 0.1, 1.5);
                    else throughput *= vec3(0.1, 1.5, 0.1);
                }
            }
            else {
                // ═══ OPAQUE MATERIALS (PBR) ═══
                
                // Importance sampling: elegir entre difuso y especular
                float specularProbability = 0.5 + 0.5 * mat.metallic;
                
                if (rand() < specularProbability) {
                    // ─── Specular reflection ───
                    vec3 H = normalize(N + randomHemisphere(N) * mat.roughness);
                    rd = reflect(rayDir, H);
                    
                    float NdotV = max(dot(N, V), 0.0);
                    float VdotH = max(dot(V, H), 0.0);
                    
                    vec3 F0 = mix(vec3(0.04), mat.albedo, mat.metallic);
                    vec3 F = fresnelSchlickVec(VdotH, F0);
                    
                    // Compensación de múltiple scattering
                    if (mat.metallic > 0.5) {
                        F += multipleScattering(F0, mat.roughness, NdotV) * 0.15;
                    }
                    
                    throughput *= F / specularProbability;
                } else {
                    // ─── Diffuse reflection ───
                    rd = randomHemisphere(N);
                    
                    float NdotL = max(dot(N, rd), 0.0);
                    vec3 albedo = mat.albedo;
                    
                    // Subsurface scattering simulado
                    if (mat.subsurface > 0.5) {
                        albedo *= mix(vec3(1.0), vec3(1.0, 0.4, 0.3), mat.subsurface * 0.6);
                    }
                    
                    throughput *= albedo * NdotL * (1.0 - mat.metallic) / (1.0 - specularProbability);
                }
                
                // Aplicar AO
                throughput *= mat.ao;
                
                // Sombras en primer rebote
                if (ENABLE_SHADOWS && bounce == 0) {
                    vec3 lightDir = normalize(vec3(3.0, 5.0, 2.0) - hit.p);
                    float shadow = calculateShadow(hit.p + N * 0.01, lightDir, 20.0);
                    throughput *= 0.3 + 0.7 * shadow;
                }
                
                ro = hit.p + rd * 0.005;
            }
            
            // ─────────────────────────────────────────────────────────────────────
            // Russian Roulette (terminar trazado temprano)
            // ─────────────────────────────────────────────────────────────────────
            if (bounce > 2) {
                float survivalProb = min(max(throughput.r, max(throughput.g, throughput.b)), 0.95);
                if (rand() > survivalProb) break;
                throughput /= survivalProb;
            }
            
            // Safety: prevenir throughput infinito
            throughput = min(throughput, vec3(10.0));
        }
        
        return safeClamp(radiance);
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // 8. MAIN - Entry point con post-processing
    // ═══════════════════════════════════════════════════════════════════════════════
    void main() {
        initRNG();

        // ─── Anti-aliasing jitter ───
        vec2 pixelCoord = gl_FragCoord.xy;
        vec2 jitter = vec2(rand(), rand()) - 0.5;
        vec2 uv = (pixelCoord + jitter - 0.5 * u_resolution) / u_resolution.y;

        // ─── Construir ray de cámara ───
        vec3 forward = normalize(u_camDir);
        vec3 right = normalize(cross(forward, u_camUp));
        vec3 up = cross(right, forward);
        
        float focalLength = 1.5; // FOV control
        vec3 rayDir = normalize(forward * focalLength + right * uv.x + up * uv.y);

        // ─── Path tracing ───
        vec3 color = pathTrace(u_camPos, rayDir);

        // ─── NaN/Inf guard (crítico para macOS) ───
        if (any(isnan(color)) || any(isinf(color))) {
            color = vec3(0.0);
        }
        
        // ─── Bloom effect ───
        if (ENABLE_BLOOM) {
            vec3 bloom = bloomThreshold(color, 2.0);
            color += bloom * 0.15;
        }

        // ─── Tone mapping (ACES aproximado) ───
        color = color * (2.51 * color + 0.03) / (color * (2.43 * color + 0.59) + 0.14);
        
        // ─── Gamma correction (sRGB) ───
        color = pow(color, vec3(1.0 / 2.2));
        
        // ─── Vignette sutil ───
        vec2 screenUV = pixelCoord / u_resolution;
        float vignette = 1.0 - 0.15 * length(screenUV - 0.5);
        color *= vignette;

        // ─── Progressive accumulation ───
        vec3 previousFrame = texture(u_texture, pixelCoord / u_resolution).rgb;
        
        float blendFactor = 1.0 / (float(u_frame) + 1.0);
        blendFactor = max(blendFactor, 0.015); // Mínimo 1.5% para evitar congelamiento
        
        if (u_frame == 0) {
            blendFactor = 1.0; // Primera frame: reemplazar completamente
        }
        
        vec3 accumulated = mix(previousFrame, color, blendFactor);
        
        // ─── Final clamp ───
        accumulated = saturate3(accumulated);

        outColor = vec4(accumulated, 1.0);
    }
    </script>

    <script>
        // ================================================================================================
        // VESTWEB ENGINE v2.0 - Main JavaScript
        // Sistema completo de motor gráfico con física, controles y API modular
        // ================================================================================================
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 1. CORE - Inicialización WebGL2 y contexto
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl2', { 
            antialias: false, 
            powerPreference: "high-performance",
            alpha: false,
            depth: false,
            stencil: false,
            preserveDrawingBuffer: false
        });
        
        if (!gl) {
            alert("WebGL 2 not supported. Please use a modern browser.");
            throw new Error("WebGL2 not available");
        }

        // Extensiones para máxima calidad (opcionales, no críticas)
        const ext_float = gl.getExtension("EXT_color_buffer_float");
        const ext_linear = gl.getExtension("OES_texture_float_linear");
        const ext_aniso = gl.getExtension("EXT_texture_filter_anisotropic");
        
        // Detectar GPU para optimizaciones específicas
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        const gpuVendor = debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'Unknown';
        const gpuRenderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Unknown';
        console.log(`GPU: ${gpuRenderer} (${gpuVendor})`);

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 2. RENDER API - Sistema modular de shaders y programas
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        const RenderAPI = {
            shaders: {},
            programs: {},
            
            // Compilar shader con validación detallada
            compileShader(type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    const log = gl.getShaderInfoLog(shader);
                    console.error(`Shader compilation error (${type === gl.VERTEX_SHADER ? 'VERTEX' : 'FRAGMENT'}):`);
                    console.error(log);
                    
                    // Mostrar líneas con errores
                    const lines = source.split('\n');
                    const errors = log.match(/(\d+):(\d+)/g);
                    if (errors) {
                        errors.forEach(err => {
                            const lineNum = parseInt(err.split(':')[1]);
                            console.error(`Line ${lineNum}: ${lines[lineNum - 1]}`);
                        });
                    }
                    return null;
                }
                return shader;
            },
            
            // Crear programa completo
            createProgram(vsSource, fsSource) {
                const vs = this.compileShader(gl.VERTEX_SHADER, vsSource);
                const fs = this.compileShader(gl.FRAGMENT_SHADER, fsSource);
                
                if (!vs || !fs) return null;
                
                const program = gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error("Program link error:", gl.getProgramInfoLog(program));
                    return null;
                }
                
                // Cleanup shaders (ya están linkeados)
                gl.deleteShader(vs);
                gl.deleteShader(fs);
                
                return program;
            },
            
            // Obtener todas las ubicaciones de uniforms
            getUniforms(program, names) {
                const locs = {};
                names.forEach(name => {
                    locs[name] = gl.getUniformLocation(program, name);
                });
                return locs;
            }
        };
        
        // Crear programa principal
        const program = RenderAPI.createProgram(
            document.getElementById('vs').innerText,
            document.getElementById('fs').innerText
        );
        
        if (!program) {
            alert("Shader compilation failed. Check console for details.");
            throw new Error("Shader compilation failed");
        }

        // Crear geometría fullscreen quad
        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,  1, -1,  -1, 1,
            -1,  1,  1, -1,   1, 1
        ]), gl.STATIC_DRAW);
        
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 3. INPUT SYSTEM - Sistema completo de controles (teclado, ratón, gamepad)
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        const InputSystem = {
            keys: {},
            mouse: { x: 0, y: 0, dx: 0, dy: 0, buttons: [false, false, false] },
            dragging: false,
            locked: false,
            gamepad: null,
            
            init() {
                // Teclado
                window.addEventListener('keydown', e => {
                    this.keys[e.key.toLowerCase()] = true;
                    this.handleSpecialKeys(e.key.toLowerCase());
                });
                window.addEventListener('keyup', e => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Ratón
                canvas.addEventListener('mousedown', e => {
                    this.dragging = true;
                    this.mouse.buttons[e.button] = true;
                    if (e.button === 0) { // Click izquierdo para pointer lock
                        canvas.requestPointerLock?.();
                    }
                });
                window.addEventListener('mouseup', e => {
                    this.dragging = false;
                    this.mouse.buttons[e.button] = false;
                });
                window.addEventListener('mousemove', e => {
                    if (document.pointerLockElement === canvas) {
                        this.mouse.dx = e.movementX;
                        this.mouse.dy = e.movementY;
                        this.locked = true;
                    } else {
                        this.mouse.dx = e.clientX - this.mouse.x;
                        this.mouse.dy = e.clientY - this.mouse.y;
                        this.mouse.x = e.clientX;
                        this.mouse.y = e.clientY;
                        this.locked = false;
                    }
                });
                
                // Pointer Lock
                document.addEventListener('pointerlockchange', () => {
                    this.locked = document.pointerLockElement === canvas;
                });
                
                // Gamepad (soporte básico)
                window.addEventListener('gamepadconnected', e => {
                    console.log('Gamepad connected:', e.gamepad.id);
                    this.gamepad = e.gamepad;
                });
                window.addEventListener('gamepaddisconnected', () => {
                    this.gamepad = null;
                });
                
                // Touch para móviles (básico)
                canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.mouse.x = touch.clientX;
                    this.mouse.y = touch.clientY;
                    this.dragging = true;
                });
                canvas.addEventListener('touchmove', e => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.mouse.dx = touch.clientX - this.mouse.x;
                    this.mouse.dy = touch.clientY - this.mouse.y;
                    this.mouse.x = touch.clientX;
                    this.mouse.y = touch.clientY;
                });
                canvas.addEventListener('touchend', () => {
                    this.dragging = false;
                });
            },
            
            handleSpecialKeys(key) {
                if (key === 'r') {
                    // Reset cámara (manejado en CameraSystem)
                    CameraSystem.reset();
                    Engine.resetFrame();
                }
                if (key === 'p') {
                    // Toggle physics
                    PhysicsSystem.enabled = !PhysicsSystem.enabled;
                }
                if (key === 'g') {
                    // Toggle gravity
                    PhysicsSystem.gravity[1] = PhysicsSystem.gravity[1] === 0 ? -9.8 : 0;
                }
                if (key === 'escape') {
                    document.exitPointerLock?.();
                }
            },
            
            getAxis(positive, negative) {
                let value = 0;
                if (this.keys[positive]) value += 1;
                if (this.keys[negative]) value -= 1;
                return value;
            },
            
            updateGamepad() {
                if (!this.gamepad) return;
                
                const gamepads = navigator.getGamepads();
                for (let gp of gamepads) {
                    if (gp && gp.index === this.gamepad.index) {
                        this.gamepad = gp;
                        break;
                    }
                }
            },
            
            getGamepadAxis(index) {
                if (!this.gamepad || !this.gamepad.axes[index]) return 0;
                const value = this.gamepad.axes[index];
                return Math.abs(value) > 0.1 ? value : 0; // Deadzone
            },
            
            isGamepadButtonPressed(index) {
                return this.gamepad?.buttons[index]?.pressed || false;
            },
            
            update() {
                this.updateGamepad();
                // Reset deltas después de procesar
                this.mouse.dx = 0;
                this.mouse.dy = 0;
            }
        };

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 4. CAMERA SYSTEM - Sistema de cámara con controles suaves
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        const CameraSystem = {
            position: [0, 3, -9],
            pitch: 0.2,
            yaw: 0,
            fov: 1.5,
            speed: 0.1,
            sensitivity: 0.003,
            smoothing: 0.15,
            
            velocity: [0, 0, 0],
            targetVelocity: [0, 0, 0],
            
            init() {
                this.reset();
            },
            
            reset() {
                this.position = [0, 3, -9];
                this.pitch = 0.2;
                this.yaw = 0;
                this.velocity = [0, 0, 0];
            },
            
            getForward() {
                return [
                    Math.sin(this.yaw) * Math.cos(this.pitch),
                    Math.sin(this.pitch),
                    Math.cos(this.yaw) * Math.cos(this.pitch)
                ];
            },
            
            getRight() {
                return [
                    Math.cos(this.yaw),
                    0,
                    -Math.sin(this.yaw)
                ];
            },
            
            getUp() {
                return [0, 1, 0];
            },
            
            update(dt) {
                let moved = false;
                
                // Rotación con ratón (natural)
                if (InputSystem.dragging || InputSystem.locked) {
                    this.yaw += InputSystem.mouse.dx * this.sensitivity;
                    this.pitch += InputSystem.mouse.dy * this.sensitivity; // Cambiado a + para movimiento natural
                    this.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, this.pitch));
                    moved = true;
                }
                
                // Movimiento con teclado
                const forward = this.getForward();
                const right = this.getRight();
                
                this.targetVelocity = [0, 0, 0];
                
                // WASD (A izquierda, D derecha)
                const moveZ = InputSystem.getAxis('w', 's');
                const moveX = InputSystem.getAxis('a', 'd'); // Invertido: A da -1, D da +1
                const moveY = InputSystem.getAxis(' ', 'shift'); // Espacio y Shift
                
                for (let i = 0; i < 3; i++) {
                    this.targetVelocity[i] += forward[i] * moveZ * this.speed;
                    this.targetVelocity[i] += right[i] * moveX * this.speed;
                }
                this.targetVelocity[1] += moveY * this.speed;
                
                // Gamepad support
                const gpX = InputSystem.getGamepadAxis(0);
                const gpY = InputSystem.getGamepadAxis(1);
                if (Math.abs(gpX) > 0 || Math.abs(gpY) > 0) {
                    for (let i = 0; i < 3; i++) {
                        this.targetVelocity[i] += forward[i] * -gpY * this.speed;
                        this.targetVelocity[i] += right[i] * gpX * this.speed;
                    }
                    moved = true;
                }
                
                // Smoothing de velocidad
                for (let i = 0; i < 3; i++) {
                    this.velocity[i] += (this.targetVelocity[i] - this.velocity[i]) * this.smoothing;
                    this.position[i] += this.velocity[i];
                    if (Math.abs(this.velocity[i]) > 0.001) moved = true;
                }
                
                return moved;
            }
        };

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 5. PHYSICS SYSTEM - Sistema de física completo con colisiones
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        const PhysicsSystem = {
            enabled: true,
            gravity: [0, -9.8, 0],
            objects: [],
            collisions: 0,
            substeps: 4,
            
            init() {
                // Crear objetos físicos de ejemplo
                this.addObject({
                    position: [2, 8, 0],
                    velocity: [0, 0, 0],
                    mass: 1.0,
                    radius: 0.5,
                    restitution: 0.7,
                    friction: 0.3,
                    dynamic: true
                });
                
                this.addObject({
                    position: [-2, 10, -1],
                    velocity: [0, 0, 0],
                    mass: 1.5,
                    radius: 0.6,
                    restitution: 0.8,
                    friction: 0.2,
                    dynamic: true
                });
                
                // Plano estático (suelo)
                this.addObject({
                    position: [0, -2, 0],
                    normal: [0, 1, 0],
                    type: 'plane',
                    dynamic: false
                });
            },
            
            addObject(obj) {
                this.objects.push({
                    type: obj.type || 'sphere',
                    position: obj.position,
                    velocity: obj.velocity || [0, 0, 0],
                    mass: obj.mass || 1.0,
                    radius: obj.radius || 1.0,
                    restitution: obj.restitution || 0.5,
                    friction: obj.friction || 0.3,
                    dynamic: obj.dynamic !== false,
                    normal: obj.normal || [0, 1, 0]
                });
            },
            
            update(dt) {
                if (!this.enabled) return;
                
                this.collisions = 0;
                const subDt = dt / this.substeps;
                
                for (let step = 0; step < this.substeps; step++) {
                    // Integración de velocidad
                    for (let obj of this.objects) {
                        if (!obj.dynamic) continue;
                        
                        // Aplicar gravedad
                        obj.velocity[0] += this.gravity[0] * subDt;
                        obj.velocity[1] += this.gravity[1] * subDt;
                        obj.velocity[2] += this.gravity[2] * subDt;
                        
                        // Integrar posición
                        obj.position[0] += obj.velocity[0] * subDt;
                        obj.position[1] += obj.velocity[1] * subDt;
                        obj.position[2] += obj.velocity[2] * subDt;
                    }
                    
                    // Detección y resolución de colisiones
                    this.detectCollisions();
                }
            },
            
            detectCollisions() {
                for (let i = 0; i < this.objects.length; i++) {
                    const objA = this.objects[i];
                    if (!objA.dynamic) continue;
                    
                    for (let j = i + 1; j < this.objects.length; j++) {
                        const objB = this.objects[j];
                        
                        if (objB.type === 'plane') {
                            this.resolvePlaneCollision(objA, objB);
                        } else if (objA.type === 'sphere' && objB.type === 'sphere') {
                            this.resolveSphereCollision(objA, objB);
                        }
                    }
                }
            },
            
            resolvePlaneCollision(sphere, plane) {
                const d = this.dot(sphere.position, plane.normal) - this.dot(plane.position, plane.normal);
                
                if (d < sphere.radius) {
                    // Colisión detectada
                    this.collisions++;
                    
                    // Corregir posición
                    const penetration = sphere.radius - d;
                    sphere.position[0] += plane.normal[0] * penetration;
                    sphere.position[1] += plane.normal[1] * penetration;
                    sphere.position[2] += plane.normal[2] * penetration;
                    
                    // Calcular velocidad relativa
                    const vn = this.dot(sphere.velocity, plane.normal);
                    
                    if (vn < 0) {
                        // Respuesta con restitución
                        const impulse = -(1 + sphere.restitution) * vn;
                        sphere.velocity[0] += plane.normal[0] * impulse;
                        sphere.velocity[1] += plane.normal[1] * impulse;
                        sphere.velocity[2] += plane.normal[2] * impulse;
                        
                        // Fricción
                        const vt = [
                            sphere.velocity[0] - plane.normal[0] * vn,
                            sphere.velocity[1] - plane.normal[1] * vn,
                            sphere.velocity[2] - plane.normal[2] * vn
                        ];
                        const vtMag = Math.sqrt(vt[0]*vt[0] + vt[1]*vt[1] + vt[2]*vt[2]);
                        if (vtMag > 0.001) {
                            const frictionImpulse = Math.min(sphere.friction * Math.abs(impulse), vtMag);
                            sphere.velocity[0] -= (vt[0] / vtMag) * frictionImpulse;
                            sphere.velocity[1] -= (vt[1] / vtMag) * frictionImpulse;
                            sphere.velocity[2] -= (vt[2] / vtMag) * frictionImpulse;
                        }
                    }
                }
            },
            
            resolveSphereCollision(sphereA, sphereB) {
                if (!sphereB.dynamic) return; // Solo esfera-esfera dinámicas
                
                const dx = sphereB.position[0] - sphereA.position[0];
                const dy = sphereB.position[1] - sphereA.position[1];
                const dz = sphereB.position[2] - sphereA.position[2];
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                const minDist = sphereA.radius + sphereB.radius;
                
                if (dist < minDist && dist > 0.001) {
                    this.collisions++;
                    
                    // Normal de colisión
                    const nx = dx / dist;
                    const ny = dy / dist;
                    const nz = dz / dist;
                    
                    // Corregir posiciones
                    const penetration = minDist - dist;
                    const totalMass = sphereA.mass + sphereB.mass;
                    const ratioA = sphereB.mass / totalMass;
                    const ratioB = sphereA.mass / totalMass;
                    
                    sphereA.position[0] -= nx * penetration * ratioA;
                    sphereA.position[1] -= ny * penetration * ratioA;
                    sphereA.position[2] -= nz * penetration * ratioA;
                    
                    sphereB.position[0] += nx * penetration * ratioB;
                    sphereB.position[1] += ny * penetration * ratioB;
                    sphereB.position[2] += nz * penetration * ratioB;
                    
                    // Respuesta de impulso
                    const dvx = sphereB.velocity[0] - sphereA.velocity[0];
                    const dvy = sphereB.velocity[1] - sphereA.velocity[1];
                    const dvz = sphereB.velocity[2] - sphereA.velocity[2];
                    const vn = dvx*nx + dvy*ny + dvz*nz;
                    
                    if (vn < 0) {
                        const restitution = Math.min(sphereA.restitution, sphereB.restitution);
                        const impulse = -(1 + restitution) * vn / totalMass;
                        
                        sphereA.velocity[0] -= nx * impulse * sphereB.mass;
                        sphereA.velocity[1] -= ny * impulse * sphereB.mass;
                        sphereA.velocity[2] -= nz * impulse * sphereB.mass;
                        
                        sphereB.velocity[0] += nx * impulse * sphereA.mass;
                        sphereB.velocity[1] += ny * impulse * sphereA.mass;
                        sphereB.velocity[2] += nz * impulse * sphereA.mass;
                    }
                }
            },
            
            dot(a, b) {
                return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
            }
        };

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 6. VIRTUAL FILE SYSTEM - Sistema de archivos virtual para assets
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        const VirtualFS = {
            files: {},
            
            init() {
                // Precargar shaders virtuales
                this.writeFile('/shaders/default.vs', document.getElementById('vs').innerText);
                this.writeFile('/shaders/default.fs', document.getElementById('fs').innerText);
                
                // Configuración del motor
                this.writeFile('/config/engine.json', JSON.stringify({
                    version: '2.0',
                    renderer: 'WebGL2',
                    maxSamples: 1000,
                    physics: {
                        enabled: true,
                        gravity: [0, -9.8, 0],
                        substeps: 4
                    },
                    camera: {
                        fov: 1.5,
                        speed: 0.1,
                        sensitivity: 0.003
                    }
                }, null, 2));
                
                console.log('VirtualFS initialized with', Object.keys(this.files).length, 'files');
            },
            
            writeFile(path, content) {
                this.files[path] = {
                    content: content,
                    timestamp: Date.now()
                };
            },
            
            readFile(path) {
                const file = this.files[path];
                return file ? file.content : null;
            },
            
            exists(path) {
                return this.files.hasOwnProperty(path);
            },
            
            listFiles(dir = '/') {
                return Object.keys(this.files).filter(path => path.startsWith(dir));
            },
            
            deleteFile(path) {
                delete this.files[path];
            }
        };

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 7. ENGINE CORE - Sistema principal del motor
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        const Engine = {
            frameCount: 0,
            running: false,
            lastTime: 0,
            deltaTime: 0,
            fps: 0,
            
            resetFrame() {
                this.frameCount = 0;
            },
            
            init() {
                console.log('🚀 Vestweb Engine v2.0 - Initializing...');
                
                // Inicializar todos los subsistemas
                InputSystem.init();
                CameraSystem.init();
                PhysicsSystem.init();
                VirtualFS.init();
                
                console.log('✅ All systems initialized');
                
                // Ocultar loading screen
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                    this.running = true;
                }, 500);
            }
        };
        
        let frameCount = 0;

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 8. RENDER BUFFERS - Ping-pong buffers para acumulación progresiva
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        const RenderBuffers = {
            textures: [],
            framebuffers: [],
            width: 0,
            height: 0,
            readIndex: 0,
            
            create() {
                // Determinar resolución óptima según GPU y pixel ratio
                const dpr = window.devicePixelRatio || 1;
                let scale = 1.0;
                
                // Optimización por plataforma
                if (gpuRenderer.includes('Apple') || gpuRenderer.includes('Intel')) {
                    scale = Math.min(dpr, 1.0); // Apple Silicon/Intel: nativa o menor
                } else if (gpuRenderer.includes('NVIDIA') || gpuRenderer.includes('AMD')) {
                    scale = Math.min(dpr, 1.5); // Nvidia/AMD: permite más resolución
                } else {
                    scale = Math.min(dpr, 1.2); // Otros: conservador
                }
                
                this.width = Math.floor(window.innerWidth * scale);
                this.height = Math.floor(window.innerHeight * scale);
                
                canvas.width = this.width;
                canvas.height = this.height;
                canvas.style.width = "100vw";
                canvas.style.height = "100vh";
                
                gl.viewport(0, 0, this.width, this.height);
                
                // Crear ping-pong buffers
                for (let i = 0; i < 2; i++) {
                    if (this.textures[i]) gl.deleteTexture(this.textures[i]);
                    if (this.framebuffers[i]) gl.deleteFramebuffer(this.framebuffers[i]);
                    
                    this.textures[i] = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, this.textures[i]);
                    
                    // Usar float si está disponible, sino UNSIGNED_BYTE
                    const internalFormat = ext_float ? gl.RGBA16F : gl.RGBA;
                    const format = gl.RGBA;
                    const type = ext_float ? gl.HALF_FLOAT : gl.UNSIGNED_BYTE;
                    
                    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, this.width, this.height, 
                                  0, format, type, null);
                    
                    // Filtrado lineal
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    
                    // Anisotropic filtering si está disponible
                    if (ext_aniso) {
                        const max = gl.getParameter(ext_aniso.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                        gl.texParameterf(gl.TEXTURE_2D, ext_aniso.TEXTURE_MAX_ANISOTROPY_EXT, max);
                    }
                    
                    // Crear framebuffer
                    this.framebuffers[i] = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[i]);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
                                           gl.TEXTURE_2D, this.textures[i], 0);
                    
                    // Verificar completitud
                    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                    if (status !== gl.FRAMEBUFFER_COMPLETE) {
                        console.error('Framebuffer incomplete:', status);
                    }
                }
                
                Engine.resetFrame();
                console.log(`Render buffers created: ${this.width}x${this.height} (${scale.toFixed(2)}x DPR)`);
            },
            
            swap() {
                this.readIndex = 1 - this.readIndex;
            },
            
            getWriteBuffer() {
                return this.framebuffers[1 - this.readIndex];
            },
            
            getReadTexture() {
                return this.textures[this.readIndex];
            }
        };
        
        // Crear buffers iniciales
        RenderBuffers.create();
        
        // Resize handler con debounce
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                RenderBuffers.create();
            }, 100);
        });

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 9. UNIFORM LOCATIONS - Cache de ubicaciones de uniforms
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        const uniforms = RenderAPI.getUniforms(program, [
            'u_resolution',
            'u_time',
            'u_frame',
            'u_texture',
            'u_camPos',
            'u_camDir',
            'u_camUp',
            'u_physicsCount'
        ]);
        
        // Arrays de uniforms para physics (máx 20 objetos)
        uniforms.u_physicsPos = [];
        uniforms.u_physicsRadius = [];
        for (let i = 0; i < 20; i++) {
            uniforms.u_physicsPos[i] = gl.getUniformLocation(program, `u_physicsPos[${i}]`);
            uniforms.u_physicsRadius[i] = gl.getUniformLocation(program, `u_physicsRadius[${i}]`);
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 10. MAIN RENDER LOOP - Loop principal optimizado
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        let lastFrameTime = performance.now();
        let fpsSmoothed = 60;
        const fpsAlpha = 0.1;
        
        function renderLoop(currentTime) {
            if (!Engine.running) {
                requestAnimationFrame(renderLoop);
                return;
            }
            
            // Calcular delta time
            Engine.deltaTime = Math.min((currentTime - lastFrameTime) / 1000, 0.1); // Cap a 100ms
            lastFrameTime = currentTime;
            
            // Calcular FPS suavizado
            const instantFps = 1 / Math.max(Engine.deltaTime, 0.001);
            fpsSmoothed = fpsSmoothed * (1 - fpsAlpha) + instantFps * fpsAlpha;
            Engine.fps = Math.round(fpsSmoothed);
            
            // Actualizar sistemas
            const cameraMoved = CameraSystem.update(Engine.deltaTime);
            PhysicsSystem.update(Engine.deltaTime);
            
            if (cameraMoved) {
                Engine.resetFrame();
            }
            
            // Renderizar frame
            renderFrame(currentTime);
            
            // Actualizar UI
            updateUI();
            
            // Limpiar input deltas
            InputSystem.update();
            
            Engine.frameCount++;
            requestAnimationFrame(renderLoop);
        }
        
        function renderFrame(time) {
            gl.useProgram(program);
            
            // Bind framebuffer de escritura
            gl.bindFramebuffer(gl.FRAMEBUFFER, RenderBuffers.getWriteBuffer());
            
            // Bind textura de lectura (frame anterior)
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, RenderBuffers.getReadTexture());
            gl.uniform1i(uniforms.u_texture, 0);
            
            // Actualizar uniforms
            gl.uniform2f(uniforms.u_resolution, RenderBuffers.width, RenderBuffers.height);
            gl.uniform1f(uniforms.u_time, time * 0.001);
            gl.uniform1i(uniforms.u_frame, Engine.frameCount);
            
            // Camera uniforms
            gl.uniform3fv(uniforms.u_camPos, CameraSystem.position);
            gl.uniform3fv(uniforms.u_camDir, CameraSystem.getForward());
            gl.uniform3fv(uniforms.u_camUp, CameraSystem.getUp());
            
            // Physics objects uniforms
            const dynamicObjects = PhysicsSystem.objects.filter(obj => obj.dynamic && obj.type === 'sphere');
            const physicsCount = Math.min(dynamicObjects.length, 20);
            gl.uniform1i(uniforms.u_physicsCount, physicsCount);
            
            for (let i = 0; i < physicsCount; i++) {
                gl.uniform3fv(uniforms.u_physicsPos[i], dynamicObjects[i].position);
                gl.uniform1f(uniforms.u_physicsRadius[i], dynamicObjects[i].radius);
            }
            
            // Dibujar quad
            gl.bindVertexArray(vao);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // Copiar a pantalla
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, RenderBuffers.getWriteBuffer());
            gl.blitFramebuffer(
                0, 0, RenderBuffers.width, RenderBuffers.height,
                0, 0, RenderBuffers.width, RenderBuffers.height,
                gl.COLOR_BUFFER_BIT, gl.LINEAR
            );
            
            // Swap buffers
            RenderBuffers.swap();
        }
        
        function updateUI() {
            document.getElementById('fpsCounter').innerText = Engine.fps;
            document.getElementById('sampleCount').innerText = Engine.frameCount;
            document.getElementById('resolution').innerText = 
                `${RenderBuffers.width}x${RenderBuffers.height}`;
            
            // GPU info (solo primera vez)
            if (Engine.frameCount === 1) {
                const gpuShort = gpuRenderer.split('(')[0].trim();
                document.getElementById('gpuInfo').innerText = 
                    gpuShort.substring(0, 20) + (gpuShort.length > 20 ? '...' : '');
            }
            
            // Physics stats
            document.getElementById('physicsObjects').innerText = 
                PhysicsSystem.objects.filter(o => o.dynamic).length;
            document.getElementById('collisions').innerText = PhysicsSystem.collisions;
            document.getElementById('gravity').innerText = 
                PhysicsSystem.gravity[1] === 0 ? 'OFF' : 'ON';
        }
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 11. ENGINE START - Inicializar y comenzar
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        // Inicializar motor
        Engine.init();
        
        // Comenzar loop de renderizado
        requestAnimationFrame(renderLoop);
        
        // Exponer API global para debugging y extensiones
        window.VESTWEB = {
            Engine,
            RenderAPI,
            InputSystem,
            CameraSystem,
            PhysicsSystem,
            VirtualFS,
            RenderBuffers,
            
            // Métodos de utilidad
            version: '2.0.0',
            info() {
                console.log(`
╔═══════════════════════════════════════╗
║     VESTWEB ENGINE v2.0               ║
║     High-Performance Graphics Engine  ║
╟───────────────────────────────────────╢
║  Systems:                             ║
║  • Render API (WebGL2)                ║
║  • Input System (KB/Mouse/Gamepad)    ║
║  • Camera System (FPS)                ║
║  • Physics System (Collisions)        ║
║  • Virtual File System                ║
║                                       ║
║  Features:                            ║
║  • PBR + Path Tracing                 ║
║  • SSAO, Bloom, Volumetric Fog        ║
║  • Real-time Physics                  ║
║  • Cross-platform optimized           ║
║  • WebGL/WebGPU ready                 ║
╚═══════════════════════════════════════╝
                `);
                console.log('GPU:', gpuRenderer);
                console.log('Resolution:', `${RenderBuffers.width}x${RenderBuffers.height}`);
                console.log('FPS:', Engine.fps);
                console.log('Samples:', Engine.frameCount);
            },
            
            // Añadir objeto físico
            addPhysicsObject(config) {
                PhysicsSystem.addObject(config);
                console.log('Physics object added:', config);
            },
            
            // Reset completo
            reset() {
                CameraSystem.reset();
                PhysicsSystem.objects = [];
                PhysicsSystem.init();
                Engine.resetFrame();
                console.log('Engine reset');
            }
        };
        
        console.log('✨ VESTWEB Engine ready! Type VESTWEB.info() for details.');
    </script>
</body>
</html>
    </script>
</body>
</html>